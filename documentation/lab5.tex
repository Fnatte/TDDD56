\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\usepackage{listings}
\usepackage{hyperref}
\lstset{
language=C,
basicstyle=\footnotesize
}
\begin{document}

\section{Lab 5}

\subsection{1. Reduction}

\subsubsection{What timing did you get for your GPU reduction? Compare it to the CPU version.}

For a very small data size the GPU code was incredibly slow, like amazingly slow:

\begin{lstlisting}
  CPU time 0.000012
  GPU time 0.124672
\end{lstlisting}


\subsubsection{Try larger data size. On what size does the GPU version get faster, or at least comparable, to the GPU?}

For a data size of 10 000 000 our CPU and GPU code runs about as slow:

\begin{lstlisting}
  CPU time 0.112159
  GPU time 0.149918
\end{lstlisting}

For a data size of 100 000 000 the GPU becomes faster:

\begin{lstlisting}
  CPU time 1.109952
  GPU time 0.382216
\end{lstlisting}


\subsubsection{How can you optimize this further? You should know at least one way.}

We could increse the number of levels. Right now we only have three levels.




\subsection{2. Bitonic merge sort}

\subsubsection{Should each thread produce one output or two? Why?}



\subsubsection{How many items can you handle in one block?}


\subsubsection{What problem must be solved when you use more than one block? How did you solve it?}


\subsubsection{What time do you get? Difference to the CPU? What is the break even size? What can you expect for a parallel CPU version? (Your conclusions here may vary between the labs.)}



\end{document}

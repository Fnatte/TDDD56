\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\usepackage{listingsutf8}
\usepackage{hyperref}
\lstset{
language=C,
basicstyle=\footnotesize
}
\begin{document}


\section{Lab 6}


\subsection{1. Getting started: Hello, World!}

\subsubsection{How is the communication between the host and the graphic card handled?}

At first we create buffers on the device where our data to and from the device can recide.

\begin{lstlisting}
	input = clCreateBuffer(context,  CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,  sizeof(char) * DATA_SIZE, a, NULL);
  	input2 = clCreateBuffer(context,  CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,  sizeof(char) * DATA_SIZE, b, NULL);
	output = clCreateBuffer(context, CL_MEM_WRITE_ONLY, sizeof(char) * DATA_SIZE, NULL, NULL);
\end{lstlisting}

With the CL_MEM_USE_HOST_PTR we ask the OpenCL implementation to use the memory referenced by the pointer as storage. It is then free to copy the data to the device, we guess, but we don't have to actively call a ``copy out the data'' command.

We do however wait for the output to be completely written to the output buffer, so there's that.

\begin{lstlisting}
  err = clEnqueueReadBuffer(commands, output, CL_TRUE, 0, sizeof(char) * count, c, 0, NULL, NULL );
\end{lstlisting}

But there's a thing we're conflicted about, we suspect that one of the comments in the hello-world program are incorrec; namely this one:

\begin{lstlisting}
  // Send data
	err  = clSetKernelArg(kernel, 0, sizeof(cl_mem), \&input);
	err |= clSetKernelArg(kernel, 1, sizeof(cl_mem), \&input2);
	err |= clSetKernelArg(kernel, 2, sizeof(cl_mem), \&output);
\end{lstlisting}

We believe that what clSetKernelArg merely tells the OpenCL implementation where it can find it's arguments, much like the OpenGL glVertexAttribPointer, and has nothing to do with the transfer of the data.

According to this [0] stack overflow question the OpenCL implementation is allowed to copy the data directly after clCreateBuffer.

[0] http://stackoverflow.com/questions/23122246/clcreatebuffer-cl-mem-use-host-ptr-when-does-opencl-framework-transfer-data


\subsubsection{What function executes your kernel?}

The function clEnqueueNDRangeKernel starts the kernel. We then wait for it to finish at the clFinish call.


\subsubsection{How does the kernel know what element to work on?}

By getting what corresponds to a thread id.

\begin{lstlisting}
  int i = get_global_id(0);
\end{lstlisting}



\subsection{2. Image Filtering}

\subsubsection{How much data did you put in local (shared memory?}

\subsubsection{How much data does each thread copy to local memory?}

\subsubsection{How did you handle the necessary overlap between the work groups?}

\subsubsection{If we would like to increase the block size, about how big work groups would be safe to use in this case? Why?}

\subsubsection{How much speedup did you get over the naive version?}


\end{document}